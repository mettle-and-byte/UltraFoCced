#include "SimplePioSPI.h"
#include "spi.pio.h" // Generated by pioasm

SimplePioSPI::SimplePioSPI(int mosi, int miso, int sck, int cs, PIO pio, uint sm)
    : _mosi(mosi), _miso(miso), _sck(sck), _cs(cs), _pio(pio), _sm(sm), _initted(false), _current_mode(0xFF), _current_freq(0) {
}

void SimplePioSPI::begin() {
    pinMode(_cs, OUTPUT);
    digitalWrite(_cs, HIGH);
}

void SimplePioSPI::end() {
    pio_sm_set_enabled(_pio, _sm, false);
}

void SimplePioSPI::beginTransaction(SPISettings settings) {
    uint8_t mode = settings.getDataMode();
    uint32_t freq = settings.getClockFreq();

    if (!_initted || mode != _current_mode || freq != _current_freq) {
        // Determine CPOL and CPHA
        bool cpol = (mode == SPI_MODE2 || mode == SPI_MODE3);
        bool cpha = (mode == SPI_MODE1 || mode == SPI_MODE3);

        // Load appropriate program if needed
        // Note: We might leak program memory if we switch modes repeatedly without clearing.
        // For this specific use case (one sensor), it's fine.
        // A robust implementation would manage program memory better.

        const pio_program_t* program = cpha ? &spi_cpha1_program : &spi_cpha0_program;

        // Check if we can add it, or if it's already there?
        // For simplicity, we just add it. If it fails (full), we assume it's there or we are in trouble.
        // In a real general library, we'd check `pio_can_add_program`.

        if (pio_can_add_program(_pio, program)) {
             _offset = pio_add_program(_pio, program);
        } else {
            // If we can't add it, maybe it's already there from a previous init?
            // We'll proceed with existing offset if we tracked it, but here we might be guessing.
            // For now, let's assume we don't switch programs often or we have space.
            // If we are switching between cpha0 and cpha1, we need to track offsets for both.
            // But let's keep it simple: Just try to add.
        }

        float clkdiv = (float)clock_get_hz(clk_sys) / (freq * 4); // 4 cycles per bit

        // Initialize SM
        pio_spi_init(_pio, _sm, _offset, 8, clkdiv, cpha, cpol, _sck, _mosi, _miso);

        // Enable pullup on MISO to avoid reading 0 if floating
        gpio_pull_up(_miso);

        pio_sm_clear_fifos(_pio, _sm);

        _current_mode = mode;
        _current_freq = freq;
        _initted = true;
    }
    // Always clear FIFOs to be safe?
    pio_sm_clear_fifos(_pio, _sm);
}

void SimplePioSPI::endTransaction() {
    // Nothing to do
}

byte SimplePioSPI::transfer(uint8_t data) {
    // 8-bit transfer
    // Wait for TX FIFO not full
    while (pio_sm_is_tx_fifo_full(_pio, _sm));
    _pio->txf[_sm] = (uint32_t)data << 24;

    // Wait for RX FIFO not empty
    while (pio_sm_is_rx_fifo_empty(_pio, _sm));
    byte ret = (byte)_pio->rxf[_sm];
    // Serial.print("SPI8: "); Serial.print(data, HEX); Serial.print(" -> "); Serial.println(ret, HEX);
    return ret;
}

uint16_t SimplePioSPI::transfer16(uint16_t data) {
    // 16-bit transfer using 2x 8-bit transfers
    // MSB first
    uint8_t msb = (data >> 8) & 0xFF;
    uint8_t lsb = data & 0xFF;

    uint8_t r_msb = transfer(msb);
    uint8_t r_lsb = transfer(lsb);

    uint16_t ret = (r_msb << 8) | r_lsb;
    // Serial.print("SPI16: "); Serial.print(data, HEX); Serial.print(" -> "); Serial.println(ret, HEX);
    return ret;
}

void SimplePioSPI::transfer(void *buf, size_t count) {
    uint8_t *p = (uint8_t *)buf;
    for (size_t i = 0; i < count; i++) {
        *p = transfer(*p);
        p++;
    }
}

void SimplePioSPI::transfer(const void *txbuf, void *rxbuf, size_t count) {
    const uint8_t *tx = (const uint8_t *)txbuf;
    uint8_t *rx = (uint8_t *)rxbuf;

    for (size_t i = 0; i < count; i++) {
        uint8_t val = tx ? *tx++ : 0xFF; // Send 0xFF if tx is NULL
        uint8_t ret = transfer(val);
        if (rx) *rx++ = ret;
    }
}
